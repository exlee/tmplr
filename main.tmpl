{### FILE empty_dir_scanner.rs ###}
use std::{
    ffi::OsStr,
    fs::{self, ReadDir},
    io,
    path::{Path, PathBuf},
};

#[derive(Debug)]
pub struct EmptyDirScanner {
    stack: Vec<PathBuf>,
    current_dir: Option<ReadDir>,
    current_empty: bool,
    current_path: Option<PathBuf>,
    search_root: PathBuf,
}

impl EmptyDirScanner {
    pub fn new<P: AsRef<Path>>(root: P) -> Self {
      let pathbuf = root.as_ref().to_path_buf();
        Self {
            stack: vec![pathbuf.clone()],
            current_dir: None,
            current_empty: true,
            current_path: None,
            search_root: pathbuf.canonicalize().unwrap(),
            
        }
    }
}

impl Iterator for EmptyDirScanner {
    type Item = io::Result<PathBuf>;

    fn next(&mut self) -> Option<Self::Item> {
        loop {
            // Active Iterator
            if let Some(ref mut entries) = self.current_dir {
                match entries.next()  {
                    Some(Ok(entry)) => {
                        let path = entry.path();
                        self.current_empty = false;
                        if path.is_dir() {
                            self.stack.push(path)
                        }
                        continue;
                    }
                    Some(Err(e)) => return Some(Err(e)),
                    None => {
                      if self.current_empty {
                        let dir = self.current_path.clone().expect("Can't unpack path");
                        self.current_dir = None;


                        return Some(Ok(dir));
                        self.current_dir = None;
                      }
                    }
                }
            }

            // New iterator
            match self.stack.pop() {
                Some(dir_path) => match fs::read_dir(dir_path.clone()) {
                    Ok(read_dir) => {
                      self.current_dir = Some(read_dir);
                      self.current_path = Some(dir_path);
                      self.current_empty = true
                    },
                    Err(e) => return Some(Err(e)),
                },
                None => return None,
            }
        }
    }
}

{### FILE file_scanner.rs ###}
use std::{
    ffi::OsStr,
    fs::{self, ReadDir},
    io,
    path::{Path, PathBuf},
};

#[derive(Debug)]
pub struct FileScanner {
    stack: Vec<PathBuf>,
    current_dir: Option<ReadDir>,
    extension: Option<String>,
}

impl FileScanner {
    pub fn new<P: AsRef<Path>>(root: P) -> Self {
        Self {
            stack: vec![root.as_ref().to_path_buf()],
            current_dir: None,
            extension: None,
        }
    }
    pub fn new_with_extension<P: AsRef<Path>>(root: P, extension: String) -> Self {
        Self {
            stack: vec![root.as_ref().to_path_buf()],
            current_dir: None,
            extension: Some(extension),
        }
    }
}

impl Iterator for FileScanner {
    type Item = io::Result<PathBuf>;

    fn next(&mut self) -> Option<Self::Item> {
        #[derive(Debug)]
        enum ExtCheck {
            NoCheck,
            Match,
            NoMatch,
        }
        fn check_ext(search_ext_opt: &Option<String>, path: &Path) -> ExtCheck {
            let Some(search_ext) = search_ext_opt else {
                return ExtCheck::NoCheck;
            };
            // Should it handle empty extension case (e.g. files that end with dot)?
            let Some(path_ext) = path.extension().and_then(|p| p.to_str()) else {
                return ExtCheck::NoMatch;
            };

            if search_ext.as_str() == path_ext {
                ExtCheck::Match
            } else {
                ExtCheck::NoMatch
            }
        }

        loop {
            // Active Iterator
            if let Some(ref mut entries) = self.current_dir {
                match entries.next() {
                    Some(Ok(entry)) => {
                        let path = entry.path();
                        if path.is_dir() {
                            self.stack.push(path)
                        } else {
                            match check_ext(&self.extension, &path) {
                                ExtCheck::NoCheck => return Some(Ok(path)),
                                ExtCheck::Match => return Some(Ok(path)),
                                ExtCheck::NoMatch => (),
                            }
                        }
                        continue;
                    }
                    Some(Err(e)) => return Some(Err(e)),
                    None => self.current_dir = None,
                }
            }

            // New iterator
            match self.stack.pop() {
                Some(dir_path) => match fs::read_dir(dir_path) {
                    Ok(read_dir) => self.current_dir = Some(read_dir),
                    Err(e) => return Some(Err(e)),
                },
                None => return None,
            }
        }
    }
}

{### FILE gen_template.rs ###}
use std::{fs, path::PathBuf};
use pathdiff::{diff_paths};

use crate::{empty_dir_scanner, file_scanner, quit_with_error, template::{self, EXTENSION, Node}};

pub fn create_template(pathbuf: PathBuf, name: String) {
  if create_template_impl(pathbuf, name).is_none() {
      quit_with_error(1, "Error template crash".into());
      unreachable!();
  }
}
fn create_template_impl(pathbuf: PathBuf, name: String) -> Option<()> {
    let files_iter = file_scanner::FileScanner::new(&pathbuf);
    let empty_dirs_iter = empty_dir_scanner::EmptyDirScanner::new(&pathbuf);
    let mut result = String::with_capacity(16*1024);

    let open = template::OPEN;
    let close = template::CLOSE;

    for dir in empty_dirs_iter.flatten() {
       	let dir_pathbuf = dir.clone();
				let relative = diff_paths(&dir_pathbuf, &pathbuf)?;
      	let path_str = relative.to_str()?;
      	let new_node = create_dir_node(path_str, name.clone());
        if let Node::Dir(path) = new_node {
    				let relative = diff_paths(&path, &pathbuf)?;
          	let path_str = relative.to_str()?;
          	result.push_str(open);
          	result.push_str(" DIR ");
          	result.push_str(path_str);
          	result.push(' ');
          	result.push_str(close);
          	result.push('\n');
      	}
    };

    for file in files_iter.flatten() {
      	let file = file.clone();
      	let file_path: &str = file.to_str()?;
      	let new_node = create_node(file_path, name.clone());
      	match new_node {
        	Node::File{path, content} =>  {
						let relative = diff_paths(&path, &pathbuf)?;
          	let path_str = relative.to_str()?;
          	result.push_str(open);
          	result.push_str(" FILE ");
          	result.push_str(path_str);
          	result.push(' ');
          	result.push_str(close);
          	result.push('\n');
          	result.push_str(&content);
          	result.push('\n');
        	},

        	Node::Dir(path) => {
						let relative = diff_paths(&path, &pathbuf)?;
          	let path_str = relative.to_str()?;
          	result.push_str(open);
          	result.push_str(" DIR ");
          	result.push_str(path_str);
          	result.push(' ');
          	result.push_str(close);
          	result.push('\n');
        	}
      	}
    }
    let mut filename: String = String::new();
    filename.push_str(name.as_str());
    filename.push('.');
    filename.push_str(EXTENSION);

    println!("{}", result);

    _ = fs::write(filename, result);

    Some(())

}
pub fn create_dir_node(path: &str, name: String) -> Node {

    let path = replace_word_bounded(path, &name, "{{ name }}");
    let pathbuf = template::validate_path_string(path.as_str()).expect("Path error");

    Node::Dir (pathbuf)
}
pub fn create_node(path: &str, name: String) -> Node {
  	let pathbuf = PathBuf::from(path);
    let Ok(content) = fs::read_to_string(pathbuf) else {
        quit_with_error(
            1,
            format!(
                "Can't read file for template creation: {}",
                path,
            ),
        );
        unreachable!();
    };

    let content = replace_word_bounded(&content, &name, "{{ name }}");
    let path = replace_word_bounded(path, &name, "{{ name }}");

    Node::File {
        path,
        content,
    }
}

fn replace_word_bounded(input: &str, target: &str, replacement: &str) -> String {
    let mut output = String::with_capacity(input.len());
    let mut last_idx = 0;

    let crash_during_replacement = || {
        quit_with_error(1, "Error during replacing string".into());
        unreachable!()
    };

    for (start, _part) in input.match_indices(target) {
        let boundary_start = if start == 0 {
            true
        } else {
            let prev_char = input.chars().nth(start-1).unwrap_or_else(crash_during_replacement);
            !prev_char.is_alphanumeric()
        };

        let end = start + target.len();
        let boundary_end = if end == input.len() {
            true
        } else {
            let next_char = input.chars().nth(end).unwrap_or_else(crash_during_replacement);
            !next_char.is_alphanumeric()
        };

        if boundary_start && boundary_end {
            output.push_str(&input[last_idx..start]);
            output.push_str(replacement);
            last_idx = end;
        }
    }
    output.push_str(&input[last_idx..]);
    output
}

{### FILE {{ name }}.rs ###}
use std::{
    collections::HashMap,
    env::{self, current_dir},
    path::{PathBuf},
    str::FromStr,
};

mod file_scanner;
mod empty_dir_scanner;
mod template;
mod gen_template;

#[derive(Debug)]
enum AppArgs {
    List,
    Create {
      path: PathBuf,
      name: String,
    },
    Make {
        template_path: PathBuf,
        variables: HashMap<String, String>,
    },
  	#[cfg(debug_assertions)]
    Debug,
}

pub fn {{ name }}() {
    let parsed = parse_args();
    let args = parsed.unwrap_or_else(|err| {
        println!("Error: {}", err);
        print_help_and_exit(0);
        unreachable!();
    });
    match args {
      	#[cfg(debug_assertions)]
        AppArgs::Debug => run_debug(&args),
        AppArgs::Make {
            template_path,
            variables,
        } => template::make(template::TemplateRequest::make(
            template_path,
            variables,
        )),
        AppArgs::List => run_list(),
        AppArgs::Create{path, name} => gen_template::create_template(path, name),
    }
}

fn run_list() {
  let templates = template::list_templates();

	if Vec::is_empty(&templates) {
  	println!("No templates found in: {}", template::templates_dir().to_string_lossy());
	}
  for tmpl_file in template::list_templates() {
    println!("{}", tmpl_file.to_string_lossy());
  }
}
fn run_debug(_args: &AppArgs) {
    let example = PathBuf::from_str("assets/example.template").unwrap();
    let template = template::read_template(example.as_path());
    let mut ctx: HashMap<String, String> = HashMap::new();
    ctx.insert("project_name".into(), "[example_project]".into());
    for node in template.as_ref().unwrap() {
        if let template::Node::File { path, content } = node {
            println!("{}", path);
            println!("{}", template::render(content, &ctx));
        }
    }

    for f in file_scanner::FileScanner::new_with_extension(current_dir().unwrap(), "rs".into()) {
        println!("{:?}", f);
    }
    gen_template::create_template(PathBuf::from("src"), "{{ name }}".into());
}
fn parse_args() -> Result<AppArgs, pico_args::Error> {
    let mut pargs = pico_args::Arguments::from_env();

    let Ok(Some(subcommand)) = pargs.subcommand() else {
        print_help_and_exit(0);
        unreachable!();
    };
    match subcommand.to_lowercase().as_str() {
      	#[cfg(debug_assertions)]
        "dbg" => Ok(AppArgs::Debug {}),
        "make" => {
            let template_path: PathBuf = pargs.free_from_str()?;
            let instance_name: String = pargs.free_from_str()?;
            let mut ctx: HashMap<String, String> = HashMap::new();

            for var in pargs.finish() {
                let str: String = var.into_string().unwrap_or("".into());

                if str.contains("=") {
                    if let Some((key, value)) = str.split_once("=") {
                        ctx.insert(key.into(), value.into());
                    }
                }
            }

            ctx.insert("name".into(), instance_name);

            let cmd = AppArgs::Make {
                template_path,
                variables: ctx,
            };

            Ok(cmd)
        }
        "create" => {
          let name: String = pargs.free_from_str()?;
          Ok(AppArgs::Create{
            path: PathBuf::from("."),
            name,
          })
        },
        "list" => Ok(AppArgs::List),
        _ => {
            print_help_and_exit(1);
            unreachable!();
        }
    }
}

fn print_help_and_exit(code: i32) {
    print!("{}", HELP);
    std::process::exit(code);
}

fn quit_with_error(code: i32, err: String) {
  eprintln!("Error: {}", err);
  std::process::exit(code);
}


const HELP: &str = "
tmpl
  make   <TEMPLATE_FILE/TEMPLATE_NAME> <NAME> VAR=VAL...
  create <TEMPLATE_FILE> <NAME>
  list   List available templates
";

{### FILE template.rs ###}
use std::{
    collections::HashMap,
    env::{self, current_dir},
    error::Error,
    fs::{self, File},
    path::{Path, PathBuf},
    str::FromStr,
};

use crate::gen_template;
use crate::{file_scanner, quit_with_error};

pub const EXTENSION: &str = "tmpl";
pub const OPEN: &str = "{###";
pub const CLOSE: &str = "###}";

#[derive(Clone, Debug)]
pub enum Node {
    Dir(PathBuf),
    File { path: String, content: String },
}
type Template = Vec<Node>;

struct TemplateContext {
    vars: HashMap<String, String>,
    filters: HashMap<String, fn(&str) -> String>,
}

#[derive(Debug)]
pub struct TemplateRequest {
    path: PathBuf,
    context: HashMap<String, String>,
}

impl TemplateRequest {
    pub fn make(path: PathBuf, context: HashMap<String, String>) -> TemplateRequest {
        TemplateRequest { path, context }
    }
}

pub fn render(template: &str, ctx: &HashMap<String, String>) -> String {
    let mut output = String::with_capacity(template.len());
    let mut chars = template.chars().peekable();

    while let Some(c) = chars.next() {
        if c == '{' && chars.peek() == Some(&'{') {
            chars.next();

            let mut inner = String::new();
            while let Some(ic) = chars.next() {
                if ic == '}' && chars.peek() == Some(&'}') {
                    chars.next();
                    break;
                }
                inner.push(ic);
            }

            let parts: Vec<&str> = inner.split('|').map(|s| s.trim()).collect();

            let key = parts[0];

            if let Some(val) = ctx.get(key) {
                let mut res = val.clone();
                for filter in &parts[1..] {
                    match *filter {
                        "upper" => res = res.to_uppercase(),
                        _ => eprintln!("Unknown filter: {}", filter),
                    }
                }
                output.push_str(&res);
            } else {
                output.push_str("{{");
                output.push_str(&inner);
                output.push_str("}}");
            }
            continue;
        }
        output.push(c);
    }
    output
}

pub fn read_template(path: &Path) -> Result<Template, String> {
    let mut result: Template = Vec::new();
    let mut cursor = 0;
    let mut current_node: Option<Node> = None;

    fn push_output(s: &str, current_node: &mut Option<Node>) {
        if let Some(Node::File { content, .. }) = current_node {
            content.push_str(s);
        }
    }

    let file_string = fs::read_to_string(path).unwrap_or("Can't read file".to_string());

    while let Some(start_offset) = file_string[cursor..].find(OPEN) {
        let tag_start = cursor + start_offset;

        push_output(&file_string[cursor..tag_start], &mut current_node);
        let content_start = tag_start + OPEN.len();
        let remaining = &file_string[content_start..];

        if let Some(end_offset) = remaining.find(CLOSE) {
            let inner = &remaining[..end_offset].trim();
            // process cmds
            let (cmd, params) = match inner.split_once(char::is_whitespace) {
                Some((c, p)) => (c.trim(), p),
                None => (*inner, "".into()),
            };

            match cmd.to_uppercase().as_str() {
                "DIR" => {
                    let file_path = validate_path_string(params)?;
                    let file_path = file_path.canonicalize().map_err(|err| err.to_string())?;
                    let new_dir = Node::Dir(file_path);
                    result.push(new_dir);
                }
                "FILE" => {
                    if let Some(node) = current_node.clone() {
                        result.push(node);
                    }


                    if let Ok(path) = validate_path_string(params) {
                        let file_path = path
                            .to_str()
                            .ok_or(String::from("Can't convert FILE path to string"))?;
                        current_node = Some(Node::File {
                            path: file_path.into(),
                            content: String::new(),
                        })
                    };
                }
                _ => {
                    eprintln!("Unknown command: {}", cmd);
                }
            }
            cursor = content_start + end_offset + CLOSE.len();
        } else {
            push_output(&file_string[tag_start..], &mut current_node);
            cursor = file_string.len();
            break;
        }
    }
    push_output(&file_string[cursor..], &mut current_node);
    if let Some(node) = current_node {
        result.push(node);
    }
    Ok(result)
}
pub fn validate_path(target_root: &Path, relative_path: &Path) -> Result<PathBuf, String> {
    let joined = target_root.join(relative_path);
    //let canonical_root = joined.canonicalize().map_err(|e| e.to_string())?;

    if joined
        .components()
        .any(|c| matches!(c, std::path::Component::ParentDir))
    {
        return Err("Target reaches outside parent directory".into());
    };

    Ok(relative_path.to_path_buf())
}

pub fn validate_path_string(str_path: &str) -> Result<PathBuf, String> {
    let curdir = current_dir().map_err(|_| "Can't get current dir")?;
    let pathbuf_result = PathBuf::from_str(str_path);
    let pathbuf: PathBuf = pathbuf_result.map_err(|_| "Not a path")?;
    let path = pathbuf.as_path();
    validate_path(curdir.as_path(), path)
}

pub(crate) fn make(request: TemplateRequest) {
    let template_result = read_template(&request.path);
    let Ok(template_entities) = template_result else {
        eprintln!("Error: {}", template_result.unwrap_err());
        return;
    };
    for entity in template_entities {
        match entity {
            Node::File { path, content } => render_to_file(&path, &content, &request.context),
            Node::Dir(path) => create_directory(path),
        }
    }
}

fn create_directory(path: PathBuf) {
    fs::create_dir_all(&path);
}

fn render_to_file(path_str: &str, content: &str, context: &HashMap<String, String>) {
    let err_quit = |_| {
        quit_with_error(1, "Invalid path in template definition".into());
        unreachable!();
    };
    let content = render(content, context);
    let path_str = render(path_str, context);
    let pathbuf = validate_path_string(path_str.as_str()).unwrap_or_else(err_quit);
    if let Some(parent_dir) = pathbuf.parent() {
        _ = fs::create_dir_all(parent_dir);
    }
    eprintln!("Path: {}", path_str);
    eprint!("{}", content);
    assert!(fs::write(pathbuf.as_path(), content).is_ok());
}

fn get_config_dir() -> PathBuf {
    if let Ok(path) = env::var("XDG_CONFIG_HOME") {
        return PathBuf::from(path).join("templater");
    }

    if let Ok(path) = env::var("HOME") {
        return PathBuf::from(path).join(".config/templater");
    }

    PathBuf::from(".")
}

pub fn list_templates() -> Vec<PathBuf> {
    file_scanner::FileScanner::new_with_extension(get_config_dir(), EXTENSION.into())
        .flatten()
        .collect()
}

pub fn templates_dir() -> PathBuf {
    get_config_dir()
}

