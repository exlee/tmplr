{### FILE Cargo.toml ###}
[package]
name = "{{ name }}"
version = "0.1.0"
edition = "2024"

[dependencies]
nix = { version = "0.30.1", features = ["fs"] }
tokio = { version = "1.49.0", features = ["rt", "macros", "fs", "io-util", "process", "sync", "rt-multi-thread"] }

{### FILE src/handle_context.rs ###}
use std::fs::File;
use std::os::fd::{AsFd, AsRawFd};
use std::os::unix::fs::PermissionsExt;
use std::sync::Arc;
use std::{
    collections::HashMap,
    env,
    path::{Path, PathBuf},
};

use nix::fcntl::{FcntlArg, OFlag, fcntl};
use tokio::io;
use tokio::sync::Mutex;

pub struct Context {
    pub(crate) tools: HashMap<String, Option<PathBuf>>,
}

impl Context {
    pub fn get_tool(&self, key: &str) -> Option<PathBuf> {
        self.tools.get(key).cloned().unwrap_or(None)
    }
    pub fn get_or_create_fifo_path(key: &str) -> std::io::Result<PathBuf> {
        let path = Self::get_fifo_path(key);

        // CLEAN SLATE: Always attempt to remove the file.
        // We ignore NotFound errors, but propagate others (e.g., PermissionDenied).
        if let Err(e) = std::fs::remove_file(&path) {
            if e.kind() != std::io::ErrorKind::NotFound {
                return Err(e);
            }
        }

        // Create the new FIFO
        nix::unistd::mkfifo(
            &path, 
            nix::sys::stat::Mode::from_bits(0o600).unwrap()
        )?;

        Ok(path)
    }
    pub fn get_fifo_path(key: &str) -> PathBuf {
        Path::new("/tmp").join(format!("{{ name }}-{}", key))
    }

    pub fn new(required_tools: &[&str]) -> Result<Self, String> {
        let mut tools = HashMap::new();

        for &tool in required_tools {
            tools.insert(tool.to_string(), find_binary(tool));
        }

        Ok(Self { tools })
    }
}

fn find_binary(name: &str) -> Option<PathBuf> {
    env::var_os("PATH").and_then(|paths| {
        env::split_paths(&paths).find_map(|dir| {
            let full_path = dir.join(name);
            if full_path.is_file() && is_executable(&full_path) {
                Some(full_path)
            } else {
                None
            }
        })
    })
}

fn is_executable(path: &Path) -> bool {
    std::fs::metadata(path)
        .map(|m| m.permissions().mode() & 0o111 != 0)
        .unwrap_or(false)
}

{### FILE src/kakoune.rs ###}
use std::process::Stdio;

use tokio::{
    io::{self, AsyncWriteExt},
    process::Command,
};

pub struct KakClient<'a>(pub &'a str);
pub struct KakSession<'a>(pub &'a str);

pub struct Kakoune {
    session: String,
    client: String,
}

impl Kakoune {
    pub fn new(session: KakSession, client: KakClient) -> Self {
        Self {
            session: session.0.into(),
            client: client.0.into(),
        }
    }

    /// `run_command` function runs Kakoune command in Session context.
    /// 
    /// For session-client context see [`Self::run_command_in_client`].
    ///
    /// # Panics
    ///
    /// Panics if Command panics or stdin can't be opened.
    ///
    /// # Errors
    ///
    /// This function will return an error if write to stdin fails or
    /// `kak` command fails.
    pub async fn run_command(&self, command: &str) -> io::Result<()> {
        println!("Kakoune {}", command);

        let mut kak_process = Command::new("kak")
            .arg("-p")
            .arg(&self.session)
            .stdin(Stdio::piped())
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .spawn()?;

        let mut kak_stdin = kak_process.stdin.take().expect("Failed to open kak stdin");
        kak_stdin.write_all(command.as_bytes()).await?;

        Ok(())
    }

    /// This function runs command in Kakoune in client context,
    ///
    /// i.e. `evaluate-commands -client CLIENT %{ ... }.`
    ///
    /// # Errors
    ///
    /// This function will return an error in same cases as [`Self::run_command`].
    pub async fn run_command_in_client(&self, command: &str) -> io::Result<()> {
        let cmd = format!(
            "evaluate-commands -client {} %{{ {} }}",
            &self.client, command
        );
        self.run_command(&cmd).await
    }
}

{### FILE src/main.rs ###}
use std::{
    env,
    io::{self},
    process::Stdio,
    sync::Arc,
};

mod handle_context;
mod kakoune;

use tokio::{fs::OpenOptions, io::AsyncWriteExt};

use crate::kakoune::Kakoune;
use crate::{
    handle_context::Context,
    kakoune::{KakClient, KakSession},
};

/// main - main entrypoint for runner
fn main() -> io::Result<()> {
    let args: Vec<String> = env::args().collect();
    if args.iter().any(|a| a == "--worker") {
        println!("Starting worker");
        return start_worker(args);
    }

    spawn_background(args);
    Ok(())
}

/// spawn_background runs the command in background process
fn spawn_background(args: Vec<String>) {
    let current_exe = env::current_exe().expect("Failed to get current exe");
    println!("Starting background");

    let _ = std::process::Command::new(current_exe)
        .args(&args[1..])
        .arg("--worker")
        .stdin(Stdio::null())
        // Uncomment these two lines for debug
        .stderr(Stdio::null())
        .stdout(Stdio::null())
        .spawn();
}

/// start_worker - background worker that parses
fn start_worker(args: Vec<String>) -> io::Result<()> {
    let rt = tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build()
        .expect("Failed to build runtime");

    rt.block_on(async {
        let clean_args: Vec<String> = args.into_iter().filter(|a| a != "--worker").collect();

        if clean_args.len() < 2 {
            return;
        }

        let session = &clean_args[1];
        let client = &clean_args[2];
        let args = &clean_args[3..];

        let kakoune = Kakoune::new(KakSession(session), KakClient(client));
        let context = Arc::new(Context::new(&[]).expect("Can't create context"));

        handle_command(kakoune, context.clone(), args)
            .await
            .expect("Failed to handle command");
    });
    Ok(())
}

/// handle_command is the main logic processor for {{ name }};
///                modify as needed
async fn handle_command(
    kakoune: Kakoune,
    context: Arc<Context>,
    args: &[String],
) -> io::Result<()> {
    let fifo_path = Context::get_or_create_fifo_path("example")?;

    kakoune
        .run_command_in_client(&format!(
            "edit -fifo {} *example*",
            fifo_path.to_string_lossy()
        ))
        .await
        .expect("Kakoune command failed");

    let mut file: tokio::fs::File = OpenOptions::new()
        .write(true)
        .read(false)
        .open(&fifo_path)
        .await?;

    file.write_all(b"Hello world").await?;
    drop(file);
    kakoune
        .run_command_in_client("echo -markup {Error}PONG PONG")
        .await
        .expect("Kakoune command failed");
    Ok(())
}

/// _searchable_args - helper for use with tools like fd/rg
/// it errors when there are no arguments or first one is empty one
fn _searchable_args(args: &[String]) -> Result<(), io::Error> {
    if args.is_empty() || args[0].is_empty() {
        return err("Search entry empty");
    }
    Ok(())
}

/// _all_args_start_with_dash - helper for use with tools like fd/rg
/// it errors when all args start with dash
fn _all_args_start_with_dash(args: &[String]) -> Result<(), io::Error> {
    let non_dashed_arg =
        args.iter()
            .fold(false, |acc, v| if acc { true } else { !v.starts_with("-") });

    if non_dashed_arg {
        Ok(())
    } else {
        return err("All args start with dash");
    }
}

/// err is a error creation helper
fn err(msg: &str) -> Result<(), std::io::Error> {
    Err(std::io::Error::other(msg))
}

